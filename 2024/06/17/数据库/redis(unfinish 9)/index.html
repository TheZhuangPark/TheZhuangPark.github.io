<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>redis一些总结 - zeon&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="zeon&#039;s blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="zeon&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="简介redis提供亚毫秒级别的响应，是内存键值数据存储，每秒处理百万请求轻轻松松，在游戏，广告，金融，医疗，会话管理，游戏。排行榜，实时分析，网约车，聊天室，流媒体，发布订阅领域都占有很高的市场。"><meta property="og:type" content="blog"><meta property="og:title" content="redis一些总结"><meta property="og:url" content="http://example.com/2024/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis(unfinish%209)/"><meta property="og:site_name" content="zeon&#039;s blog"><meta property="og:description" content="简介redis提供亚毫秒级别的响应，是内存键值数据存储，每秒处理百万请求轻轻松松，在游戏，广告，金融，医疗，会话管理，游戏。排行榜，实时分析，网约车，聊天室，流媒体，发布订阅领域都占有很高的市场。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2024-06-17T15:21:30.768Z"><meta property="article:modified_time" content="2024-04-18T16:00:00.000Z"><meta property="article:author" content="Sam"><meta property="article:tag" content="redis"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis(unfinish%209)/"},"headline":"redis一些总结","image":["http://example.com/img/og_image.png"],"datePublished":"2024-06-17T15:21:30.768Z","dateModified":"2024-04-18T16:00:00.000Z","author":{"@type":"Person","name":"Sam"},"publisher":{"@type":"Organization","name":"zeon's blog","logo":{"@type":"ImageObject","url":"http://example.com/img/mylogo.png"}},"description":"简介redis提供亚毫秒级别的响应，是内存键值数据存储，每秒处理百万请求轻轻松松，在游戏，广告，金融，医疗，会话管理，游戏。排行榜，实时分析，网约车，聊天室，流媒体，发布订阅领域都占有很高的市场。"}</script><link rel="canonical" href="http://example.com/2024/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis(unfinish%209)/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/mylogo.png" alt="zeon&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-06-17T15:21:30.768Z" title="6/17/2024, 11:21:30 PM">2024-06-17</time></span><span class="level-item">37 minutes read (About 5592 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">redis一些总结</h1><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redis提供亚毫秒级别的响应，是内存键值数据存储，每秒处理百万请求轻轻松松，在游戏，广告，金融，医疗，会话管理，游戏。排行榜，实时分析，网约车，聊天室，流媒体，发布订阅领域都占有很高的市场。</p>
<span id="more"></span>
<ul>
<li>性能极致：读速度110000（11w）次&#x2F;s, 写 81000（8w) 次每秒</li>
<li>丰富的数据类型：支持string，lists，hashes，set。</li>
<li>原子：操作都是原子性</li>
<li>特性：支持发布订阅，通知，key过期</li>
</ul>
<h3 id="与memcached对比"><a href="#与memcached对比" class="headerlink" title="与memcached对比"></a>与memcached对比</h3><ul>
<li>数据结构比memcached（接下来我会用mc来代称）丰富，mc支持的是ky结构，redis丰富很多</li>
<li>redis比mc块很多，切单节点并发更高，多配置提高性能</li>
<li>可靠性比mc好，提供数据持久化选项，可以保存数据到磁盘上</li>
<li>扩展性比mc，主从复制，集群模式。</li>
<li>场景更多，可用于复杂数据结构类型，典型场景有：消息队列mq，缓存，会话管理，分布式锁。mc则是用于简单的kv缓存用来提高web性能。<br>redis典型场景很多</li>
</ul>
<p>缓存：用于web或移动端的会话数据管理，api调用查询结果。</p>
<p>实时数据处理：大型社交网络，游戏，用户活动跟踪，实时事件统计。</p>
<p>分布式锁：协调分布式系统的并发控制。</p>
<p>消息队列：异步处理任务，推送通知等等。</p>
<p>地理位置：查找附近商店等等定位。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>对于redis而言，所有的key都是字符串，value则有五种。</p>
<p>分别是：</p>
<ul>
<li><p>1 string： 可以是字符串，可以是整数，浮点数</p>
</li>
<li><p>2 List：链表，节点包含一个字符串，可以push，pop</p>
</li>
<li><p>3 Set：无序集合，基础方式查看存在，添加，获取，删除，计算交集，并集，差集。</p>
</li>
<li><p>4 Hash： 哈希表</p>
</li>
<li><p>5 Sorted Set：类似集合但是有序，每个元素有一个分数，根据分数进行排序（排行榜最多）<br>还有其他的五个特殊数据类型：</p>
</li>
<li><p>1 Streams:  有序，持久化的，高性能消息传递系统，类似消息队列，支持多个消费者并发消费。</p>
</li>
<li><p>2 Geospatial indexes：支持地理位置信息存储和索引，经纬度进行地理位置查询。</p>
</li>
<li><p>3 Bitmaps： 存储只有1和0数据，可以进行位运算和统计。</p>
</li>
<li><p>4 Bitfields：可以存储不同长度的二进制数据，位运算和类型转换。</p>
</li>
<li><p>5 HpyerLogLog：基数估计算法，可以低内存估算一个集合的元素个数，帮助统计和分析。<br>问题：一个字符串类型的值能存储最大容量是多少？是 512 MB（536,870,912 bytes）</p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串在这里几个特性：</p>
<ul>
<li>快速读写：纳秒级别</li>
<li>支持各种编码：raw，int，数据内容自适应选择，节省内存空间</li>
<li>支持各种操作：设置，获取，删除，添加，自增自减</li>
<li>批量操作：batch操作提高性能</li>
<li>过期时间：设置好，到点了自己删除kv值</li>
<li>计数器：可以作为计数器使用，自增自减</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>常见操作：GET，SET，GETSET，还有INCR &amp; DECR &amp; INCRBY &amp; DECRBY：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># 连接到 Redis 服务器</span><br><span class="line">client = redis.StrictRedis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line"># SET 和 GET 示例</span><br><span class="line">client.set(&#x27;mykey&#x27;, &#x27;Hello, Redis!&#x27;)</span><br><span class="line">value = client.get(&#x27;mykey&#x27;)</span><br><span class="line">print(value.decode(&#x27;utf-8&#x27;))  # 输出: Hello, Redis!</span><br><span class="line"></span><br><span class="line"># GETSET 示例</span><br><span class="line">client.set(&#x27;mykey&#x27;, &#x27;Hello, Redis!&#x27;)</span><br><span class="line">old_value = client.getset(&#x27;mykey&#x27;, &#x27;New Value&#x27;)</span><br><span class="line">print(old_value.decode(&#x27;utf-8&#x27;))  # 输出: Hello, Redis!</span><br><span class="line">new_value = client.get(&#x27;mykey&#x27;)</span><br><span class="line">print(new_value.decode(&#x27;utf-8&#x27;))  # 输出: New Value</span><br><span class="line"></span><br><span class="line"># INCR 和 DECR 示例</span><br><span class="line">client.set(&#x27;counter&#x27;, 0)</span><br><span class="line">client.incr(&#x27;counter&#x27;)</span><br><span class="line">print(client.get(&#x27;counter&#x27;).decode(&#x27;utf-8&#x27;))  # 输出: 1</span><br><span class="line">client.decr(&#x27;counter&#x27;)</span><br><span class="line">print(client.get(&#x27;counter&#x27;).decode(&#x27;utf-8&#x27;))  # 输出: 0</span><br><span class="line"></span><br><span class="line"># INCRBY 和 DECRBY 示例</span><br><span class="line">client.set(&#x27;counter&#x27;, 0)</span><br><span class="line">client.incrby(&#x27;counter&#x27;, 10)</span><br><span class="line">print(client.get(&#x27;counter&#x27;).decode(&#x27;utf-8&#x27;))  # 输出: 10</span><br><span class="line">client.decrby(&#x27;counter&#x27;, 5)</span><br><span class="line">print(client.get(&#x27;counter&#x27;).decode(&#x27;utf-8&#x27;))  # 输出: 5</span><br></pre></td></tr></table></figure>
<p>其他操作可以参考网络</p>
<h3 id="实现方式sds"><a href="#实现方式sds" class="headerlink" title="实现方式sds"></a>实现方式sds</h3><p>redis实现字符串底层是靠 Simple Dynamic String，简单动态字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __attribute__ ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    uint8_t len; /* used */</span><br><span class="line">    uint8_t alloc; /* excluding the header and null terminator */</span><br><span class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取字符串长度的时间复杂度位O(1)，因为sds里面的len存储了长度值。</li>
<li>不容易缓冲区溢出，因为传统c字符串不会记录长度值，sds会，空间不足则申请，不容易溢出。</li>
<li>c语系的字符串stl容器之类修改内容是会导致重新分配内存，性能不高，redis则采用了两种方式去解决，第一是空间预分配：当对sds进行拓展，redis会位sds分配好内存，根据公式分配多余的free空间，用于备用。第二是，惰性空间释放，分配多余的空间后，如果字符串内容缩水，则不会立即回收，而是当再次操作依旧未使用多余空间，才会导致回收。</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>zset用处很大，它不允许重复元素，而且每个元素会关联一个double类型的分数，redis正是通过这个分数对元素进行从小到大排序。</p>
<p>zset的一个元素具备三个元素，分别是key（键），score（排序用的），member（值）。</p>
<h3 id="zset的常用操作"><a href="#zset的常用操作" class="headerlink" title="zset的常用操作"></a>zset的常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"># 连接到 Redis 服务器</span><br><span class="line">r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"># 添加和更新成员</span><br><span class="line">r.zadd(&#x27;myzset&#x27;, &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2&#125;)</span><br><span class="line"># 获取成员的分数</span><br><span class="line">score_one = r.zscore(&#x27;myzset&#x27;, &#x27;one&#x27;)</span><br><span class="line">print(f&quot;Score of &#x27;one&#x27;: &#123;score_one&#125;&quot;)</span><br><span class="line"># 获取集合中成员的数量</span><br><span class="line">count = r.zcard(&#x27;myzset&#x27;)</span><br><span class="line">print(f&quot;Number of members in &#x27;myzset&#x27;: &#123;count&#125;&quot;)</span><br><span class="line"># 获取成员的排名（从小到大）</span><br><span class="line">rank_one = r.zrank(&#x27;myzset&#x27;, &#x27;one&#x27;)</span><br><span class="line">print(f&quot;Rank of &#x27;one&#x27;: &#123;rank_one&#125;&quot;)</span><br><span class="line"># 获取成员的逆序排名（从大到小）</span><br><span class="line">revrank_one = r.zrevrank(&#x27;myzset&#x27;, &#x27;one&#x27;)</span><br><span class="line">print(f&quot;Reverse rank of &#x27;one&#x27;: &#123;revrank_one&#125;&quot;)</span><br><span class="line"># 获取有序集合中所有成员</span><br><span class="line">members = r.zrange(&#x27;myzset&#x27;, 0, -1, withscores=True)</span><br><span class="line">print(f&quot;All members in &#x27;myzset&#x27;: &#123;members&#125;&quot;)</span><br><span class="line"># 删除有序集合中的成员</span><br><span class="line">r.zrem(&#x27;myzset&#x27;, &#x27;one&#x27;)</span><br><span class="line">print(f&quot;After removing &#x27;one&#x27;: &#123;r.zrange(&#x27;myzset&#x27;, 0, -1, withscores=True)&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="zset的底层结构"><a href="#zset的底层结构" class="headerlink" title="zset的底层结构"></a>zset的底层结构</h3><p>分两种场景，分别是元素多的时候，还有元素少的时候（元素数量少于 128 的时候</p>
<p>每个元素的长度小于 64 字节)。</p>
<ul>
<li>当元素多的时候，使用的是跳跃表按小到大存（[score,value]），和哈希表，由哈希表维护元素和分数值，跳跃表维护顺序。</li>
<li>当元素少的时候。使用压缩列表，元素被编码连续的二进制块，按排序分数大小排序，可以将多个元素压缩到一个连续的内存空间内。<br>对于跳跃表可以参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54869087">https://zhuanlan.zhihu.com/p/54869087</a></li>
</ul>
<h3 id="为什么不用平衡树"><a href="#为什么不用平衡树" class="headerlink" title="为什么不用平衡树"></a>为什么不用平衡树</h3><ul>
<li>在各种数据库内（AVL，红黑树，B+, B树）都是常客，但是为什么不用这类树结构维护有序。因为范围查找的时候，树操作比skiplist复杂，树还要进行中序遍历不超过最大值的节点。而skiplist只是简单的遍历。</li>
<li>树的插入和删除都会引发树结构的变化，skiplist插入删除只是调整指针而已，然后读取，插入，和删除操作对于redis来说非常高发。</li>
</ul>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><ul>
<li>排行榜: redis zset常客，把点击次数，时间当score。</li>
<li>时间轴：将元素的时间当作socre。</li>
<li>队列系统：将元素的优先级别当作socre。</li>
<li>去重：zset不允许重复元素。</li>
</ul>
<h3 id="与哈希表对比"><a href="#与哈希表对比" class="headerlink" title="与哈希表对比"></a>与哈希表对比</h3><p>哈希表的底层实现是依靠字典来实现，内部使用链地址法解决哈希冲突，当kv值增加的时候渐进式对哈希表rehash扩缩，避免一次性花大时间来重新计算哈希值。</p>
<p>可以参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/dict.h">https://github.com/redis/redis/blob/unstable/src/dict.h</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/dict.c">https://github.com/redis/redis/blob/unstable/src/dict.c</a></p>
<p>使用场景就不多赘述。</p>
<h2 id="hepyerLogLog"><a href="#hepyerLogLog" class="headerlink" title="hepyerLogLog"></a>hepyerLogLog</h2><p>对于如何统计海量数据？这是一个基数算法，搞笑计算一个大集合里的独立元素个数，而不需要加载集合到内存中。最主要优势在于使用非常小的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># 连接到 Redis 服务器</span><br><span class="line">r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line"># 添加元素到 HyperLogLog</span><br><span class="line">r.pfadd(&#x27;myhll&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;)</span><br><span class="line">r.pfadd(&#x27;myhll&#x27;, &#x27;a&#x27;, &#x27;f&#x27;, &#x27;g&#x27;)</span><br><span class="line"></span><br><span class="line"># 获取基数估算值</span><br><span class="line">count = r.pfcount(&#x27;myhll&#x27;)</span><br><span class="line">print(f&quot;Estimated number of unique elements: &#123;count&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 合并多个 HyperLogLog</span><br><span class="line">r.pfadd(&#x27;another_hll&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;)</span><br><span class="line">r.pfmerge(&#x27;merged_hll&#x27;, &#x27;myhll&#x27;, &#x27;another_hll&#x27;)</span><br><span class="line">merged_count = r.pfcount(&#x27;merged_hll&#x27;)</span><br><span class="line">print(f&quot;Estimated number of unique elements in merged HLL: &#123;merged_count&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>1、统计每日活跃用户数、月活跃用户数等指标，特别是针对大数据场景。</p>
<p>2、统计不同用户的去重个数，比如计算网站独立访客数量。</p>
<p>3、统计不同 IP 地址的去重数量，可以用于网络安全领域，比如 DDoS 攻击的防御。</p>
<h3 id="底层算法："><a href="#底层算法：" class="headerlink" title="底层算法："></a>底层算法：</h3><p>主要利用了前导0，就是左边开数0的数目，举个例子，把所有ip地址通过哈希函数转化为多个随机数，然后分成多个子集后，通过前导0计算基础，之后计算的子集的估计值的调和平均值。</p>
<h2 id="redis线程"><a href="#redis线程" class="headerlink" title="redis线程"></a>redis线程</h2><p>对于redis而言，是一个事件启动型引擎，第一种事件是文件事件（主要是和客户端产生交互，连接，接受，读取，写入，关闭），第二种事件是时间事件（清除过期键，服务状态统计）。</p>
<p>但是redis在事件处理器模块是单线程，只是使用了多路复用技术：</p>
<p>(多路复用技术）</p>
<ol>
<li>监听多个 socket：使用 I&#x2F;O 多路复用技术（如 epoll）来监听多个客户端 socket。</li>
<li>事件触发：当某个 socket 上有事件发生时（如客户端发送数据到服务器），I&#x2F;O 多路复用会将此事件通知 Redis。</li>
<li>事件处理：Redis 在事件触发后，调用预先注册的事件处理函数来处理这个事件。</li>
<li>继续监听：处理完事件后，Redis 继续监听所有的 socket，以等待下一个事件的到来。<br>来以此监听多个socket，实现多个client的并发处理（不是并行），这样不需要锁，而不需要切换线程。在一台linux上，redis实例每秒传递的请求百万级别，cpu根本不是其瓶颈所在，而是受限于内存，网络。但是这也不妨碍在cpu层，进行对它的优化，比如部署多个redis实例。</li>
</ol>
<h3 id="redis多线程"><a href="#redis多线程" class="headerlink" title="redis多线程"></a>redis多线程</h3><p>在redis上只有IO操作才是多线程，使用多个cpu核心来分担IO读写负载。具体使用了一个IO线程池子来处理IO事件，主线程乃单线程用来监听连接事件，线程池子处理读写事件。</p>
<h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>一联想其事务，都知道一个事务包含多个操作，redis的事务时一次性，顺序性，排他性的。</p>
<p>事务命令有五个：</p>
<p>1 MULTI 开启事务块</p>
<p>2 EXEC 执行事事务</p>
<p>3 DISCARD 取消事务</p>
<p>4 WATCH 监控键，键被修改，事务则打断</p>
<p>5 UNWATCN 取消监控</p>
<p>执行EXEC的时候，事务被放进队列里，当轮到的时候才执行里面所有的操作。</p>
<p>但是redis事务有点不太一样。</p>
<ul>
<li><p>隔离操作没有那么复杂只是事务执行过程不会被其他客户端打断。</p>
</li>
<li><p>没有多隔离级别概念，没有可重复读之类的level，并发执行多个事务时会互相影响的。</p>
</li>
<li><p>事务不保证原子操作，不支持因为被其他事务影响而回滚的行为。<br>但是这里的它的回滚不能称之完全回滚</p>
</li>
<li><p>在入队之前，已经检查出事务里的操作错误，那入队都错误。</p>
</li>
<li><p>在执行前，如果检查出现异常，比如键不存在，也不会执行。</p>
</li>
<li><p>在执行过程种，出现错误，则事务取消，但是！成功的部分是生效的。<br>所以不能说是事务回滚。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"># 连接到 Redis</span><br><span class="line">r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line"># WATCH 键 &#x27;foo&#x27;</span><br><span class="line">r.watch(&#x27;foo&#x27;)</span><br><span class="line"># 开始一个事务</span><br><span class="line">pipeline = r.pipeline()</span><br><span class="line">try:</span><br><span class="line">    # 添加一些命令到事务中</span><br><span class="line">    pipeline.multi()</span><br><span class="line">    pipeline.set(&#x27;foo&#x27;, &#x27;bar&#x27;)</span><br><span class="line">    pipeline.incr(&#x27;counter&#x27;)</span><br><span class="line"></span><br><span class="line">    # 执行事务</span><br><span class="line">    pipeline.execute()</span><br><span class="line">except redis.WatchError:</span><br><span class="line">    # 事务被取消，因为 &#x27;foo&#x27; 被其他客户端修改</span><br><span class="line">    print(&quot;Transaction aborted due to concurrent modification&quot;)</span><br><span class="line"># 取消监视键 &#x27;foo&#x27;</span><br><span class="line">r.unwatch()</span><br></pre></td></tr></table></figure>
<h2 id="redis消息队列"><a href="#redis消息队列" class="headerlink" title="redis消息队列"></a>redis消息队列</h2><p>消息队列的特点总共就4个：</p>
<ul>
<li>1 可靠性：网络故障系统崩溃，或者消费者暂时的离线，都不应该影响到消息传递。</li>
<li>2 顺序性：消息按顺序发送。</li>
<li>3 并发：支持多个消费者，多个生产者。</li>
<li>4 扩展性：根据系统负载动态缩小或增大。<br>redis可以实现消息队列的方式有三种</li>
</ul>
<h3 id="List作为消息队列"><a href="#List作为消息队列" class="headerlink" title="List作为消息队列"></a>List作为消息队列</h3><p>Redis 的 LIST 数据结构可以用作简单的队列。使用 LPUSH 将消息推入队列，使用 RPOP 从队列中取出消息。</p>
<ul>
<li>优点：实现简单，适合小规模、简单的消息队列。</li>
<li>缺点：不支持消息持久化、消息重放和消费者组。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># 连接到 Redis</span><br><span class="line">r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line"># 生产者：将消息推入队列</span><br><span class="line">def producer(queue_name, message):</span><br><span class="line">    r.lpush(queue_name, message)</span><br><span class="line"></span><br><span class="line"># 消费者：从队列中取出消息</span><br><span class="line">def consumer(queue_name):</span><br><span class="line">    while True:</span><br><span class="line">        message = r.rpop(queue_name)</span><br><span class="line">        if message:</span><br><span class="line">            print(f&quot;Consumed message: &#123;message.decode(&#x27;utf-8&#x27;)&#125;&quot;)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">queue_name = &#x27;message_queue&#x27;</span><br><span class="line"></span><br><span class="line"># 生产者推入消息</span><br><span class="line">producer(queue_name, &#x27;Message 1&#x27;)</span><br><span class="line">producer(queue_name, &#x27;Message 2&#x27;)</span><br><span class="line"></span><br><span class="line"># 消费者消费消息</span><br><span class="line">consumer(queue_name)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>发布订阅是一种简单的消息传递模式，消息被发布到频道，所有订阅该频道的客户端都能接收到消息。</p>
<ul>
<li>优点：实时消息传递，适合广播消息。</li>
<li>缺点：消息不持久化，订阅者必须在线才能接收到消息。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 连接到 Redis</span><br><span class="line">r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line"># 发布者：发布消息到频道</span><br><span class="line">def publisher(channel, message):</span><br><span class="line">    r.publish(channel, message)</span><br><span class="line"></span><br><span class="line"># 订阅者：订阅频道并处理消息</span><br><span class="line">def subscriber(channel):</span><br><span class="line">    pubsub = r.pubsub()</span><br><span class="line">    pubsub.subscribe(channel)</span><br><span class="line"></span><br><span class="line">    for message in pubsub.listen():</span><br><span class="line">        if message[&#x27;type&#x27;] == &#x27;message&#x27;:</span><br><span class="line">            print(f&quot;Received message: &#123;message[&#x27;data&#x27;].decode(&#x27;utf-8&#x27;)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">channel_name = &#x27;my_channel&#x27;</span><br><span class="line"></span><br><span class="line"># 启动订阅者线程</span><br><span class="line">subscriber_thread = threading.Thread(target=subscriber, args=(channel_name,))</span><br><span class="line">subscriber_thread.start()</span><br><span class="line"></span><br><span class="line"># 发布者发布消息</span><br><span class="line">publisher(channel_name, &#x27;Message 1&#x27;)</span><br><span class="line">publisher(channel_name, &#x27;Message 2&#x27;）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>Redis Streams 是一种强大的消息队列系统，支持消息持久化、消费者组和消息确认等高级功能。</p>
<ul>
<li><p>优点：支持持久化、消费者组、消息确认和重放，适合复杂、高可靠性需求的消息队列。</p>
</li>
<li><p>缺点：相对复杂，学习成本较高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># 连接到 Redis</span><br><span class="line">r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line"># 生产者：添加消息到流</span><br><span class="line">def producer(stream_name, message):</span><br><span class="line">    r.xadd(stream_name, message)</span><br><span class="line"></span><br><span class="line"># 消费者：读取流中的消息</span><br><span class="line">def consumer(stream_name, group_name, consumer_name):</span><br><span class="line">    try:</span><br><span class="line">        r.xgroup_create(stream_name, group_name, id=&#x27;0&#x27;, mkstream=True)</span><br><span class="line">    except redis.exceptions.ResponseError:</span><br><span class="line">        pass  # 消费组已经存在</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        messages = r.xreadgroup(group_name, consumer_name, &#123;stream_name: &#x27;&gt;&#x27;&#125;, count=1, block=5000)</span><br><span class="line">        if messages:</span><br><span class="line">            for stream, msgs in messages:</span><br><span class="line">                for msg_id, msg in msgs:</span><br><span class="line">                    print(f&quot;Consumed message ID: &#123;msg_id&#125;, message: &#123;msg&#125;&quot;)</span><br><span class="line">                    # 确认消息已被处理</span><br><span class="line">                    r.xack(stream_name, group_name, msg_id)</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">stream_name = &#x27;mystream&#x27;</span><br><span class="line">group_name = &#x27;mygroup&#x27;</span><br><span class="line">consumer_name = &#x27;consumer1&#x27;</span><br><span class="line"></span><br><span class="line"># 启动消费者线程</span><br><span class="line">import threading</span><br><span class="line">consumer_thread = threading.Thread(target=consumer, args=(stream_name, group_name, consumer_name))</span><br><span class="line">consumer_thread.start()</span><br><span class="line"></span><br><span class="line"># 生产者推入消息</span><br><span class="line">producer(stream_name, &#123;&#x27;field1&#x27;: &#x27;value1&#x27;&#125;)</span><br><span class="line">producer(stream_name, &#123;&#x27;field2&#x27;: &#x27;value2&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里三者最大的区别在于只有stream是支持持久化的，也就是可以再系统崩溃各种情况下不影响消息的传递。也支持消费组。但是比较复杂。所以如果想要构造一个可靠的，消息队列应该选择的是Streams。<br>(PS：</p>
</li>
<li><p>Redis 适用于需要低延迟和高吞吐的小规模实时应用，如缓存和短期任务队列。</p>
</li>
<li><p>Kafka 适用于需要高可用性和可扩展性的大规模数据流处理，如日志收集、实时数据流处理和事件流系统。<br>）</p>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁需要满足几个特性</p>
<ul>
<li>1 互斥性：就像一个单机锁上多个进程只能获得一个。</li>
<li>2 高可用性：再多个机器小部分机器挂了也不会影响。</li>
<li>3 锁超时：如果某机器获得了锁，然后挂机了，那么应该规定时间内还锁。</li>
<li>4 独占性：加锁解锁都由一个机器来执行，不能A机器加锁，B机器解锁。</li>
</ul>
<h3 id="加锁操作："><a href="#加锁操作：" class="headerlink" title="加锁操作："></a>加锁操作：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>
<p>值是自己随机设置的，NX是表示lockname不存在才能SET成功，PX 30000是代表30秒是自动过期时间，一个合理的值。<br>当A机器的进程加锁了后，B机器的进程也想过来加锁，发现无法SET，因为NX表示lockname不存在才可以SET成功，所以进入了自旋遍历SET的循环里。</p>
<h3 id="解锁操作："><a href="#解锁操作：" class="headerlink" title="解锁操作："></a>解锁操作：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET lock_name</span><br><span class="line">#进行value与自己的lock value进行对比，对比成功则删除</span><br><span class="line">DEL lock_name</span><br></pre></td></tr></table></figure>
<p>当A机器删除了lockname之后，下一瞬间B机器发现自己可以set了，所以锁被B机器获取了。 </p>
<h3 id="分布锁的原子性"><a href="#分布锁的原子性" class="headerlink" title="分布锁的原子性"></a>分布锁的原子性</h3><p>有那么一种场景：</p>
<p>A机器set lockname成功了</p>
<p>A访问共享资源</p>
<p>A get lockname，进行value对比</p>
<p>A 突然挂机了</p>
<p>B 等30秒获得了锁，set lockname成功</p>
<p>A 恢复了执行 del lockname操作</p>
<p>(也就是A删除了B添加的锁)</p>
<p>正好redis的事务可以有watch异常，这个时候释放锁使用multi()命令，这样B set lockname 成功</p>
<p>户后，A恢复上线了，会马上抛异常watcherror，放弃事务了。</p>
<h3 id="集群redlock算法"><a href="#集群redlock算法" class="headerlink" title="集群redlock算法"></a>集群redlock算法</h3><p>假设redis单个节点挂了，那导致分布式锁没用了，这是不可以接受的。</p>
<p>所以redis集群会基于一个半数议会制度来实现分布式锁。</p>
<p>假设机器A，会依次对多个独立的redis节点加锁，如果机器A能够对半数以上的redis节点加锁成功，则认为A获得了锁。由于A已经锁了半数以上的redis节点，B机器是绝对无法获得半数以上的redis节点支持。</p>
<p>当对每个redis节点加锁的时候，要对加锁操作设置超时时间，一旦A机器完成对所有节点加锁，就要计算总耗时t。</p>
<ul>
<li>成功条件1：超过半数的redis节点支持加锁成功。</li>
<li>成功条件2：整个加锁时间没有超过锁的有效时间，且重新计算锁的有效时间。<br>PS 如果加锁失败，只能把解锁操作发给所有的redis节点。</li>
</ul>
<h2 id="秒杀的场景"><a href="#秒杀的场景" class="headerlink" title="秒杀的场景"></a>秒杀的场景</h2><p>秒杀系统在如今这个环境特别常见，假如某平台打算低价送飞天茅台。</p>
<ul>
<li>1 造成大量用户同一时间点击网页</li>
<li>2 访问量远大于库存数目</li>
<li>3 业务流程极其简单，就是下单减少库存</li>
</ul>
<h3 id="cpu内存"><a href="#cpu内存" class="headerlink" title="cpu内存"></a>cpu内存</h3><p>ssd固态硬盘读写速度是磁盘的100倍，内存又是ssd的10倍以上，也就是说使用ssd是写入磁盘的1000倍以上，原有的写入磁盘的秒杀系统需要1000台机器的话，那么现在1台机器就嫩搞定。但是会有人问，假设是多个redis实例来应付海量的请求，那么访问的redis实例挂了，“为之奈何？“， 那只能说该用户倒霉了，没秒到。</p>
<p>最后得到了订单序列再持久化到硬盘里，不会丢失数据，只需要写入内存返回秒杀成功给客户端就ok了。</p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>用户请求将写入内存将立即返回，通常使用MQ来实现，所以需要从内存读取该数据，使用多个线程来异步从内存中异步读取数据。</p>
<h3 id="分布式处理"><a href="#分布式处理" class="headerlink" title="分布式处理"></a>分布式处理</h3><p>如果cpu内存，和异步处理，一台机器处理不来海量内存，可以分布式使用10台甚至百台机器，把请求通过hash均匀分布（paxos算法，hash ring算法）打到不同机器上，redis cluster就是这样的分布式系统。</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>用redis的列表list作为商品库存队列，安装商品id和库存数目存入list里面。</p>
<p>用redis的hash表当作订单列表，把用户id和商品id存入列表里。</p>
<p>当请求抢购，则商品队列pop出一个商品id，并且将用户id和商品id存入订单系统中。</p>
<p>如果商品队列空了，说明卖完了，返回抢购完了返回给用用户。</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/redis/">redis</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/06/17/ai%E5%B7%A5%E7%A8%8B/triton%20+%20chatglm4%20(finish)/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">triton + chatglm4 部署</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/06/17/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC(finish)/"><span class="level-item">滑动窗口最大值</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/./img/myavatar.png" alt="Sam"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Sam</p><p class="is-size-6 is-block">极客，星际流浪者</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>现居深圳，2年达拉斯</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">19</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://google.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google</span></span><span class="level-right"><span class="level-item tag">google.com</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-17T15:22:02.589Z">2024-06-17</time></p><p class="title"><a href="/2024/06/17/ai%E5%B7%A5%E7%A8%8B/triton%20+%20chatglm4%20(finish)/">triton + chatglm4 部署</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-17T15:21:30.768Z">2024-06-17</time></p><p class="title"><a href="/2024/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis(unfinish%209)/">redis一些总结</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-17T15:20:11.449Z">2024-06-17</time></p><p class="title"><a href="/2024/06/17/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC(finish)/">滑动窗口最大值</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-03T14:59:19.717Z">2024-06-03</time></p><p class="title"><a href="/2024/06/03/%E5%89%8D%E7%AB%AF/typescript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%88finish%EF%BC%89/">TypeScript基本语法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-03T14:40:24.890Z">2024-06-03</time></p><p class="title"><a href="/2024/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%EF%BC%88%E7%B4%A2%E5%BC%95skip%EF%BC%89/">关系型数据库的基础总结</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">41</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="tag">AI(人工智能)</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Agents/"><span class="tag">Agents</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-c/"><span class="tag">Language(c++)</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-python/"><span class="tag">Language(python)</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E7%B3%BB%E7%BB%9F/"><span class="tag">Linux系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Triton/"><span class="tag">Triton</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker%E5%AE%B9%E5%99%A8/"><span class="tag">docker容器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llm-%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"><span class="tag">llm(语言模型)</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/unfinish/"><span class="tag">unfinish</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8E%E6%AE%B5%E6%9E%B6%E6%9E%84/"><span class="tag">后段架构</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">向量数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE/"><span class="tag">数据</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/mylogo.png" alt="zeon&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Sam</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>